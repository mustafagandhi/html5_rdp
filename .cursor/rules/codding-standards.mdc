---
alwaysApply: true
---
# 🧑‍💻 Coding Standards and Best Practices

This document outlines the coding guidelines and best practices for developing and maintaining the Real Remote Desktop platform, including both the browser-based client and the native host agent.

---

## 📦 JavaScript Standards (Frontend)

* Use **ES6+ features**: arrow functions, destructuring, spread/rest, async/await.
* Enforce **strict linting rules** with ESLint (`eslint:recommended`, `prettier`, `airbnb-base`).
* **TypeScript** is recommended for type safety in large components.
* Implement consistent **error handling** with `try/catch` and custom error classes.
* Use **ES6 modules** (`import/export`) instead of CommonJS.

---

## 🧱 HTML Standards

* Use **semantic HTML5 elements**: `<main>`, `<section>`, `<article>`, etc.
* Follow **WCAG 2.1 AA** accessibility compliance.
* Include required **meta tags**, responsive viewport, and charset definitions.
* Follow **progressive enhancement** principles.
* Ensure all pages validate against W3C standards.

---

## 🎨 CSS Standards

* Use **CSS Grid** and **Flexbox** for layout structure.
* Define and reuse **CSS custom properties** (variables).
* Follow **mobile-first** responsive design.
* Adopt **BEM methodology** for naming classes.
* Use **CSS Modules** or **CSS-in-JS** (e.g. styled-components, Emotion) for scoped styles.

---

## 🚀 Performance Guidelines

* **Minimize bundle size** using tree-shaking and code splitting.
* Enable **lazy loading** for routes and components.
* Offload intensive tasks using **Web Workers**.
* Optimize **Canvas rendering** by limiting reflows and repaints.
* Use **browser caching**, `Cache-Control`, and service workers where applicable.

---

## 🔐 Security Guidelines

* **Sanitize and validate** all user inputs.
* Enforce a strict **Content Security Policy (CSP)**.
* Serve all content over **HTTPS** only.
* Use **Web Crypto API** for cryptographic operations.
* Perform **regular dependency and code audits**.

---

## 📁 Code Organization (Frontend)

* Follow **modular architecture** with isolated concerns.
* Maintain **consistent folder and file naming conventions** (e.g. kebab-case).
* Write **inline documentation** and maintain a `README.md` per major component.
* Implement **unit and integration tests** with Jest or Vitest.
* Enforce a **peer code review** process before merging.

---

## 🌐 Browser Compatibility

* Support the **last 2 versions** of major browsers (Chrome, Firefox, Safari, Edge).
* Implement **graceful degradation** for unsupported features.
* Use **feature detection** (e.g. `typeof WebSocket !== 'undefined'`) over browser detection.
* Include **polyfills** (via core-js or custom) for legacy support.

---

## 🖥️ Native Agent Standards (Rust / Go)

### 🧰 Language

* Prefer **Rust** or **Go** for the native agent.
* Enforce formatting: `rustfmt` / `gofmt` and linting: `clippy` / `golint`.

### 📁 Directory Structure

```
agent/
├── src/
│   ├── main.rs / main.go
│   ├── capture/         # Frame capture abstraction
│   ├── transport/       # WebRTC/WebSocket handler
│   ├── input/           # Input event injection
│   ├── auth/            # Token validation, pairing
│   ├── config/          # Configuration parser
│   └── platform/        # OS-specific code
└── installer/           # Windows (NSIS) or Linux (.deb/.rpm)
```

### 🧠 Best Practices

* Use `Result<T, E>` or `error wrapping` instead of panics.
* Avoid global state; pass dependencies explicitly.
* Gracefully release memory, processes, and threads on shutdown.
* Avoid `unsafe` blocks in Rust unless well-documented.

### 🧪 Testing & CI

* Write unit and integration tests
* Use `cargo test` or `go test ./...`
* Run security scans with `cargo audit`, `gosec`, or similar
* Enforce lint, format, and test checks in CI pipelines

### 🔐 Security Practices

* Use short-lived, signed tokens
* Disable debug endpoints in production
* Strip debug symbols from release builds
* Run agent under least-privilege user if possible

### 🎥 Frame Capture & Encoding

* Use platform-native GPU acceleration (DXGI, PipeWire, etc.)
* Encode with `openh264`, `x264`, or `gstreamer`
* Target WebRTC-compatible formats: H.264, VP8, AV1

### 📡 Transport Layer

* Use `WebRTC` (Pion, webrtc.rs) or `Secure WebSocket`
* Use QUIC or UDP when available; fallback to TCP
* Separate control and media channels for performance

### 🛠️ Packaging

* Use `NSIS` or `WiX` for Windows
* Use `.deb`, `.rpm`, or AppImage for Linux
* Include signed installer builds and changelogs
* Version with semantic versioning

